{"./":{"url":"./","title":"学习笔记","keywords":"","body":"1. 我的学习库1. 我的学习库 Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-23 10:51:40 "},"Framework/Framework.html":{"url":"Framework/Framework.html","title":"Framework","keywords":"","body":"1. 框架1. 框架 Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-23 16:55:04 "},"Framework/MyBatis/MyBatis.html":{"url":"Framework/MyBatis/MyBatis.html","title":"MyBatis","keywords":"","body":"1. MyBatis1. MyBatis Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-23 16:56:36 "},"Framework/MyBatis/Introduce.html":{"url":"Framework/MyBatis/Introduce.html","title":"MyBatis 简介","keywords":"","body":"1. MyBatis 历史2. MyBatis 特性3. MyBatis 下载4. MyBatis 和其他持久化层技术的对比1. MyBatis 历史 MyBatis 最初是 Apache 的一个开源项目 IBatis，2010 年 6 月这个项目由 Apache Software Foundation 迁移到了 Google Code。随着开发团队转投 Google Code 旗下，IBatis 3.x 正式更名为 MyBatis。代码于 2013 年 11 月迁移到 GitHub。 IBatis 一词来源于 Internet 和 Abatis 的组合，是一个基于 Java 的持久层框架。IBatis 提供的持久层框架包括 SQL Maps 和 Data Access Objects【DAO】 2. MyBatis 特性 MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集 MyBatis 可以使用简单的 XML 或注解用于配置和原始映射，将接口和 Java 的 POJO【Plain Old Java Objects，普通的 Java 对象】映射成数据库中的记录 MyBatis 是一个半自动的 ORM【Object Relation Mapping】框架 3. MyBatis 下载 GitHub 4. MyBatis 和其他持久化层技术的对比 JDBC SQL 夹杂在 Java 代码中耦合度高，导致硬编码内伤 维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见 代码冗长，开发效率低 Hibernate 和 JPA 操作简便，开发效率高 程序中的长难复杂 SQL 需要绕过框架 内部自动生产的 SQL，不容易做特殊优化 基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难 反射操作太多，导致数据库性能下降 MyBatis 轻量级，性能出色 SQL 和 Java 编码分开，功能边界清晰。Java 代码专注业务、SQL 语句专注数据 开发效率稍逊于 Hibernate，但是完全能够接受 Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-23 17:04:23 "},"Framework/MyBatis/Entry.html":{"url":"Framework/MyBatis/Entry.html","title":"搭建 MyBatis 开发环境","keywords":"","body":"1. 开发环境2. 创建 Maven 工程3. 创建 MyBatis 的核心配置文件4. 创建 Mapper 接口5. 创建 MyBatis 的映射文件5.1. 相关概念5.2. 映射文件的命名规则5.3. 注意点5.4. 代码6. 通过 JUnit 测试功能7. 加入 log4j 日志功能1. 开发环境 IDEA 构建工具：Maven MySQL MyBatis 2. 创建 Maven 工程 1、将打包方式设置为 jar 的打包方式： jar 2、引入依赖 pom.xml 3. 创建 MyBatis 的核心配置文件 习惯上命名为 mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合 Spring 之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。 核心配置文件主要用于配置连接数据库的环境以及 MyBatis 的全局配置信息，核心配置文件存放的位置是 src/main/resources 目录下。 mybatis-config.xml 4. 创建 Mapper 接口 MyBatis 中的 Mapper 接口相当于以前的 DAO。但是区别在于，Mapper 仅仅是接口，我们不需要提供实现类。 UserMapper.java 5. 创建 MyBatis 的映射文件 5.1. 相关概念 ORM【Object Relationship Mapping】对象关系映射： 对象：Java 的实体类对象 关系：关系型数据库 映射：二者之间的对应关系 Java 概念 数据库概念 类 表 属性 字段【列】 对象 记录【行】 5.2. 映射文件的命名规则 表所对应的实体类的类名 + Mapper.xml，例如：表 User，映射的实体类为 User，所对应的映射文件为 UserMapper.xml 因此一个映射文件对应一个实体类，对应一张表的操作 MyBatis 映射文件用于编写 SQL，访问以及操作表中的数据 MyBatis 映射文件存放的位置是 src/main/resources/mappers 目录下 5.3. 注意点 MyBatis 中可以面向接口操作数据，要保证两个一致： Mapper 接口的全类名和映射文件的命名空间【NameSpace】保持一致 Mapper 接口中方法的方法名和映射文件中编写 SQL 的标签 id 属性保持一致 5.4. 代码 UserMapper.xml 6. 通过 JUnit 测试功能 SqlSession：代表 Java 程序和数据库之间的会话【HttpSession 是 Java 程序和浏览器之间的会话】。 SqlSessionFactory：是生产 SqlSession 的工厂。 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。 UserMapperTest.java 此时需要手动提交事务，如果要自动提交事务，则在获取 SqlSession 对象时，使用 SqlSession sqlSession = sqlSessionFactory.openSession(true)，传入一个 Boolean 类型的参数，值为 true，这样就可以自动提交。 7. 加入 log4j 日志功能 1、加入依赖 log4j log4j 1.2.17 2、加入 log4j 的配置文件 log4j 的配置文件名为 log4j.xml，存放的位置是 src/main/resources 目录下 日志的级别：FATAL【致命】> ERROR【错误】> WARN【警告】> INFO【信息】> DEBUG【调试】从左到右打印的内容越来越详细 log4j.xml Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-24 21:26:02 "},"Framework/MyBatis/TypeAlias.html":{"url":"Framework/MyBatis/TypeAlias.html","title":"MyBatis 默认的类型别名","keywords":"","body":"1. MyBatis 默认的类型别名1. MyBatis 默认的类型别名 Alias Mapped Type _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal Decimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-23 17:16:28 "},"Framework/MyBatis/CURD.html":{"url":"Framework/MyBatis/CURD.html","title":"MyBatis 的增删改查","keywords":"","body":"1. MyBatis 的增删改查1.1. 添加1.2. 删除1.3. 修改1.4. 查询一个实体类对象2. 查询集合3. 注意1. MyBatis 的增删改查 UserMapper.xml 1.1. 添加 insert into user values (null, '张三', '123', 23, '女') 1.2. 删除 delete from user where id = 5 1.3. 修改 update user set username = \"张三\" where id = 6 1.4. 查询一个实体类对象 select * from user where id = 6 2. 查询集合 select * from user 3. 注意 查询的标签 select 必须设置属性 resultType 或 resultMap，用于设置实体类和数据库表的映射关系 resultType：自动映射，用于属性名和表中字段名一致的情况 resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况 当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常 TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值 Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-23 17:18:41 "},"Framework/MyBatis/Configuration.html":{"url":"Framework/MyBatis/Configuration.html","title":"MyBatis 的核心配置文件","keywords":"","body":"1. MyBatis 的核心配置文件1. MyBatis 的核心配置文件 核心配置文件中的标签必须按照固定的顺序【有的标签可以不写，但顺序一定不能乱】： properties settings typeAliases typeHandlers objectFactory objectWrapperFactory reflectorFactory plugins environments databaseIdProvider mappers --> --> --> Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-23 17:24:56 "},"Framework/Spring/Spring.html":{"url":"Framework/Spring/Spring.html","title":"Spring","keywords":"","body":"1. Spring1. Spring Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-23 16:55:45 "},"Framework/SpringBoot/SpringBoot.html":{"url":"Framework/SpringBoot/SpringBoot.html","title":"SpringBoot","keywords":"","body":"1. SpringBoot1. SpringBoot Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-23 16:57:25 "},"Tools/Tools.html":{"url":"Tools/Tools.html","title":"Tools","keywords":"","body":"1. 工具1. 工具 Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-23 20:42:25 "},"Tools/GitBook/GitBook.html":{"url":"Tools/GitBook/GitBook.html","title":"GitBook","keywords":"","body":"1. GitBook 系列1. GitBook 系列 参考文章 Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-23 17:11:08 "},"Tools/GitBook/Install.html":{"url":"Tools/GitBook/Install.html","title":"安装教程","keywords":"","body":"1. 简介2. 环境安装2.1. 下载和安装 Node.js2.2. 安装 gitbook-cli3. 总结1. 简介 GitBook 是什么？其实用一句话就可以概括，它是一个能将使用 MarkDown 语法的 md 格式文档，快速制作成各种格式电子书的工具。 常被用于编写文档或者电子书，特点是方便简洁，易于使用。只要熟悉轻量级标记语法的 MarkDown 语法，就能使用 GitBook 来制作各种格式的电子书。接下来笔者就来分享一下自己使用 GitBook 的方法和经验，会分类来介绍，感兴趣的可以关注笔者关于 GitBook 这个系列的文章。 2. 环境安装 2.1. 下载和安装 Node.js 官网 中文镜像网站 注意: 基于截止到目前的 GitBook V3.2.3 版本，需要使用 NodeJs 的 v10+ 版本，否则会产生各种报错。 2.2. 安装 gitbook-cli $ npm config set registry http://registry.npm.taobao.org $ npm install gitbook-cli -g 安装完成之后，可以通过如下命令进行验证 GitBook 是否安装成功： $ gitbook -V CLI version: 2.3.2 GitBook version: 3.2.3 3. 总结 总之，GitBook 就是一个电子书生成工具，类似与 Git，Git 是一个代码仓库管理工具，用于管理代码文件，并且可以生成代码的变更记录，同时具备上传这些文件和变更记录到指定的服务器。那么同理，我们也可以结合 GitBook 和 Git 来管理我们的文档和生成的电子书文件。当然，本书主要介绍 GitBook，关于 Git 的相关知识，可以参考其他相关的教程。 Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-23 17:05:58 "},"Tools/GitBook/Plugins.html":{"url":"Tools/GitBook/Plugins.html","title":"插件教程","keywords":"","body":"1. 介绍2. 默认插件2.1. 禁用插件2.2. 添加插件2.3. 插件属性的配置3. 实用的插件1. 介绍 GitBook 支持相关的插件进行编辑，所以这里我们介绍一下 GitBook 的插件，看看如何使用这些插件，进行页面的设计，使其更加美观。 在 GitBook 中可以在书籍的配置文件 book.json 中来进行插件的相关配置。比如有很多好用的插件，可以很好的拓展书籍的外观，可用性或者其他方便的使用，所以接下来就一起来看看 GitBook 中插件的使用吧。 首先，在和 README.md 和 SUMMARY.md 的同级目录下查看是否有 book.json，如果没有的话，创建一个 book.json，book.json 的大概目录层级如下所示： { \"title\": \"学习笔记\", \"author\": \"黄志平\", \"plugins\": [ \"livereload\", \"anchor-navigation-ex\", \"theme-default\", \"search\", \"chapter-fold\", \"code\", \"splitter\", \"-lunr\", \"-search\", \"search-pro\", \"custom-favicon\", \"pageview-count\", \"tbfed-pagefooter\", \"popup\", \"-sharing\", \"sharing-plus\", \"prism\", \"-highlight\" ], \"pluginsConfig\": { \"search\": { \"maxSearchResults\": 10 }, \"hide-element\": { \"elements\": [ \".gitbook-link\" ] }, \"favicon\": \"icon/favicon.ico\", \"tbfed-pagefooter\": { \"copyright\": \"Copyright &copy hzhiping.github.io 2019\", \"modify_label\": \"文章最后修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"sharing\": { \"douban\": true, \"facebook\": true, \"google\": true, \"pocket\": true, \"qq\": true, \"qzone\": true, \"twitter\": true, \"weibo\": true, \"all\": [ \"douban\", \"facebook\", \"google\", \"instapaper\", \"linkedin\", \"twitter\", \"weibo\", \"messenger\", \"qq\", \"qzone\", \"viber\", \"whatsapp\" ] }, \"prism\": { \"css\": [ \"prismjs/themes/prism-solarizedlight.css\" ], \"lang\": { \"flow\": \"typescript\" }, \"ignore\": [ \"mermaid\", \"eval-js\" ] } }, \"structure\": { \"readme\": \"README.md\" } } 2. 默认插件 在 GitBook 中自带了 5 个默认的插件： highlight：语法高亮插件，代码高亮功能 search：搜索插件，不支持中文搜索 sharing：分享插件，右上角分享功能 livereload：热加载插件，为 GitBook 编辑进行实时重新预览加载 2.1. 禁用插件 如果需要去除或者禁用 GitBook 中的某个插件，可以在插件名称前面添加“-”即可： \"plugins\": [ \"-search\", \"-highlight\", \"-sharing\", \"-font-settings\", \"-livereload\", ... ] 2.2. 添加插件 如果需要添加一些第三方的自定义插件，可以在 plugins 中添加需要的插件名称列表： \"plugins\": [ \"-search\", \"advanced-emoji\", \"search-pro\", \"github\", \"splitter\", \"anchor-navigation-ex\", \"chapter-fold\", \"expandable-chapters-small\", \"code\", \"alerts\", \"insert-logo\", \"flexible-alerts\", ... ] 2.3. 插件属性的配置 配置插件的属性在书籍配置文件中的 pluginsConfig 中进行相关插件的属性配置。 例如要配置 insert-logo 插件的相关属性： \"pluginsConfig\": { \"insert-logo\": { \"url\": \"jim-logo.png\", \"style\": \"background: none; max-height: 100px; min-height: 30px\" } } 3. 实用的插件 实用的插件介绍如下： { \"title\": \"学习笔记\", \"author\": \"黄志平\", \"plugins\": [ // 热部署，目前不知道为什么，这个插件不能实现热部署，没找到办法，知道可告知一下。 \"livereload\", // 插件会在右上角添加一个 github 的图标，可以通过插件属性配置链接，点击后可以进入自定义的链接页面 \"github\", // 可以在 GitBook 使用 emoji 表情 \"advanced-emoji\", \"image-captions\", // 悬浮目录和回到顶部 \"anchor-navigation-ex\", // 折叠侧边栏 \"expandable-chapters-small\", // 默认主题 \"theme-default\", \"search\", // 章节折叠插件 \"chapter-fold\", \"code\", \"splitter\", \"-lunr\", \"-search\", \"search-pro\", \"custom-favicon\", \"pageview-count\", // 页脚和版权 \"tbfed-pagefooter\", \"popup\", \"-sharing\", \"sharing-plus\", // 代码高亮主题 \"prism\", // 禁用默认主题 \"-highlight\" ], \"pluginsConfig\": { \"search\": { \"maxSearchResults\": 10 }, \"hide-element\": { \"elements\": [ \".gitbook-link\" ] }, \"favicon\": \"icon/favicon.ico\", \"tbfed-pagefooter\": { \"copyright\": \"Copyright &copy hzhiping.github.io 2019\", \"modify_label\": \"文章最后修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"sharing\": { \"douban\": true, \"facebook\": true, \"google\": true, \"pocket\": true, \"qq\": true, \"qzone\": true, \"twitter\": true, \"weibo\": true, \"all\": [ \"douban\", \"facebook\", \"google\", \"instapaper\", \"linkedin\", \"twitter\", \"weibo\", \"messenger\", \"qq\", \"qzone\", \"viber\", \"whatsapp\" ] }, \"prism\": { \"css\": [ \"prismjs/themes/prism-solarizedlight.css\" ], \"lang\": { \"flow\": \"typescript\" }, \"ignore\": [ \"mermaid\", \"eval-js\" ] }, \"github\": { \"url\": \"https://github.com/hzhiping\" } }, \"structure\": { \"readme\": \"README.md\" } } Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-23 17:06:32 "},"Java/Java.html":{"url":"Java/Java.html","title":"Java","keywords":"","body":"1. Java1. Java Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-23 16:48:21 "},"Java/JavaSE.html":{"url":"Java/JavaSE.html","title":"JavaSE","keywords":"","body":"1. JavaSE1. JavaSE Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-23 16:48:30 "},"Java/Install.html":{"url":"Java/Install.html","title":"开发环境搭建","keywords":"","body":"1. 什么是 JDK、JRE1.1. JDK 版本选择2. JDK 下载3. Windows 安装 JDK4. Linux 中安装编译器4.1. 卸载系统自带 JDK4.2. 下载4.3. 解压4.4. 配置环境变量4.5. 刷新环境变量4.6. 测试安装5. 文件结构1. 什么是 JDK、JRE JDK【Java Development Kit】：是 Java 程序开发工具包，包含 JRE 和开发人员使用的工具。 JRE【Java Runtime Environment】：是 Java 程序的运行时环境，包含 JVM 和运行时所需要的核心类库。 如下是 Java 8.0 Platform： Figure: Java 8.0 Platform 小结： JDK = JRE + 开发工具集【例如 javac 编译工具等】 JRE = JVM + Java SE 标准类库 1.1. JDK 版本选择 Figure: JDK 版本选择 自 Java 8 版本发布以来，其后的每次更新，都会有小伙伴高呼：Java8 YYDS！ 论坛的声音：“你发任你发，我用 Java 8！” 数据说话 1： JRebel 于 2022 年 4 月前后发布了《2022 年 Java 生态系统状况报告》，报告中提到使用 Java 11 的占比最多，Java 8 紧随其后，如下图。而此前 2020 年的报告显示，Java 8 占比达到了 84.48%。 Figure: 数据说话 我的分析： G1 是最受欢迎的 GC 算法。Java 11 及更高版本的 G1 收集器是默认的 GC，而 Java 8 中并不是。出于对 G1 的喜爱，很多开发者才会选择抛弃 Java 8。 数据说话 2： 此外，某美国软件开发商在对近千名专业的 Java 开发者调研后，发布的《2022 年 Java 开发者生产力报告》称：八年前发布的 Java 8 依然是 Java 中应用最广泛的版本，占比 37%，其次是 Java 11，占比 29%。 Figure: Java 之父说话 Spring 框架说话： 在 Java 17 正式发布之前，Java 开发框架 Spring 率先在官博宣布，Spring Framework 6 和 SpringBoot 3 计划在 2022 年第四季度实现总体可用性的高端基线： Java 17+【来自 Spring Framework 5.3.x 线中的 Java 8-17】 Jakarta EE 9+【来自 Spring 框架 5.3.x 线中的 Java EE 7-8】 Spring 官方说明： Figure: Spring 官方说话 意味着：SpringBoot 3.0 是需要用 Java 17 和 Spring 6.0 为基础建设。如果从企业选型最新 SpringBoot 3.0 作为架构来说，它搭配 JDK 17 肯定是标配了。 2. JDK 下载 下载网址【Oracle 公司官网】：Oracle 官网 3. Windows 安装 JDK 1、双击即可执行安装，如下所示： Figure: 双击安装 2、选择安装，这里仅仅选择开发工具，另外的源代码后面可以用反编译进行查看，公共JRE也是不需要安装的，然后点击更改，修改安装路径： Figure: 安装目录 公共 JRE 是一个独立的 JRE 系统，会单独安装在系统的其他路径下。公用 JRE 会向 Internet Explorer 浏览器和系统中注册 Java 运行时环境。通过这种方式，系统中任何应用程序都可以使用公用 JRE。由于现在在网页上执行 Applet 的机会越来越少，而且完全可以选择使用 JDK 目录下的 JRE 来运行 Java 程序，因此没有太大必要安装公共 JRE。 3、配置环境变量：此电脑 —> 属性 —> 高级系统设置 —> 高级 —> 环境变量，在这里我们需要配置三个东西，分别是 JAVA_HOME、Path、CLASSPATH： Figure: 配置 JAVA_HOME Figure: 配置 PATH 最后是配置 CLASSPATH，注意 CLASSPATH 格式，具体内容如下所示： .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 这样子，在 Windows 中配置 JDK 就完成了。我们在 DOS 界面进行验证： Figure: 验证版本 Figure: 验证编译器 4. Linux 中安装编译器 系统环境：CentOS 7、jdk1.8.0_161 4.1. 卸载系统自带 JDK 首先需要卸载自带的 JDK，以便使用我们自己安装的 JDK 版本，命令如下： # 查找自带的 JDK $ rpm -qa | grep jdk # 卸载该 JDK $ rpm -e --nodeps java-1.5.0-gcj-1.5.0.0-29.1.el6.x86_64 4.2. 下载 首先要到官网下载 Linux 的版本的 JDK，下载链接。 4.3. 解压 下载完了之后，将下载的软件包上传到 Linux 上，然后解压即可： $ tar zxf jdk-8u11-linux-x64.tar.gz -C /usr/local 4.4. 配置环境变量 当我们解压完成之后，需要配置环境变量，在 /etc/profile 文件追加相关内容： # 设置 JAVA_HOME export JAVA_HOME=/usr/local/jdk1.8.0_161 export JRE_HOME=/usr/local/jdk1.8.0_161/jre export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib export PATH=$PATH:$JAVA_HOME/bin 4.5. 刷新环境变量 source /etc/profile 4.6. 测试安装 $ java -version java version \"1.8.0_161\" Java(TM) SE Runtime Environment (build 1.8.0_161-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode) 5. 文件结构 安装完成后，可在 JDK 安装路径下看到如下的文件路径： bin：该路径下存放了 JDK 的各种工具命令，常用的 javac、java 等命令就放在该路径下。 db：该路径是安装 Java DB 的路径。 demo：该路径下存放了 JDK 提供的演示代码，初学者可以参考这些演示代码。 jre：该路径下安装的就是运行 Java 程序所必需的 JRE 环境。 lib：该路径下存放的是 JDK 工具命令的实际执行程序。 sample：该路径下存放了 JDK 提供的一些简单示例代码，初学者可以参考这些示例代码。 src.zip：该压缩文件里存放的就是 Java 所有核心类库的源代码。 README 和 LICENSE 等说明性文档。 在上面路径中，bin 路径是一个非常有用的路径，这个路径下包含了编译和运行 Java 程序的 javac 和 java 两个命令。除此之外，还包含了 appletviewer、jar 等大量工具命令。 Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-23 17:05:08 "},"Java/Variable.html":{"url":"Java/Variable.html","title":"变量","keywords":"","body":"1. 为什么需要变量2. 初识变量3. Java 中变量的数据类型4. 变量的使用4.1. 步骤 1：变量的声明1. 为什么需要变量 一花一世界，如果把一个程序看做一个世界或一个社会的话，那么变量就是程序世界的花花草草、万事万物。即，变量是程序中不可或缺的组成单位，最基本的存储单元。 2. 初识变量 变量的概念： 内存中的一个存储区域，该区域的数据可以在同一个类型范围内不断变化 变量的构成包含三个要素：数据类型、变量名、存储的值 Java 中变量声明的格式：数据类型 变量名 = 变量值 变量的作用：用于在内存中保存数据 使用变量需要注意： Java 中每个变量必须先声明，后使用。 使用变量名来访问这块区域的数据。 变量的作用域：其定义所在的一对 {} 内。 变量只有在其作用域内才有效。出了作用域，变量不可以再被调用。 同一个作用域内，不能定义重名的变量。 3. Java 中变量的数据类型 Java 中的变量的数据类型分为两大类： 基本数据类型：包括整数类型、浮点数类型、字符类型、布尔类型 引用数据类型：包括数组、类、接口、枚举、注解、记录 Figure: 变量数据类型 4. 变量的使用 4.1. 步骤 1：变量的声明 格式：数据类型 变量名； // 例如： // 存储一个整数类型的年龄 int age; // 存储一个小数类型的体重 double weight; // 存储一个单字符类型的性别 char gender; // 存储一个布尔类型的婚姻状态 boolean marry; // 存储一个字符串类型的姓名 String name; // 声明多个同类型的变量 int a, b, c; // 表示 a，b，c 三个变量都是 int 类型 注意：变量的数据类型可以是基本数据类型，也可以是引用数据类型。 步骤 2： 给变量赋值，就是把“值”存到该变量代表的内存空间中。同时，给变量赋的值类型必须与变量声明的类型一致或兼容。 变量赋值的语法格式：变量名 = 值; 举例 1：可以使用合适类型的常量值给已经声明的变量赋值 age = 18; weight = 109; gender = '女'; 举例 2：可以使用其他变量或者表达式给变量赋值 int m = 1; int n = m; int x = 1; int y = 2; int z = 2 * x + y; 举例 3：变量可以反复赋值 // 先声明，后初始化 char gender; gender = '女'; // 给变量重新赋值，修改 gender 变量的值 gender = '男'; // gender = 男 System.out.println(\"gender = \" + gender); 举例 4：也可以将变量的声明和赋值一并执行 boolean isBeauty = true; String name = \"迪丽热巴\"; 内存结构如图： Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-23 17:05:32 "},"Java/NewFeature.html":{"url":"Java/NewFeature.html","title":"新特性","keywords":"","body":"1. 新特性1. 新特性 Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-03-24 21:35:19 "},"Java/Java8.html":{"url":"Java/Java8.html","title":"Java 8 的新特性","keywords":"","body":"1. 新特性简介2. Lambda 表达式2.1. 为啥使用 Lambda 表达式？2.2. Lambda 表达式语法2.3. 类型推断2.4. 练习3. 函数式接口3.1. 什么是函数式接口？3.2. 自定义函数式接口3.3. 作为参数传递 Lambda 表达式3.4. Java 内置函数式接口4. 方法引用与构造器引用4.1. 方法引用4.2. 构造器引用4.3. 数组引用5. Stream API5.1. 了解 Stream5.2. 什么是 Stream5.3. Stream 的操作三个步骤5.3.1. 创建 Stream5.3.2. Stream 的中间操作5.3.3. Stream 的终止操作5.3.4. Stream练习5.4. 并行流与串行流5.5. 了解 Fork 和 Join 框架5.5.1. Fork 和 Join 的简介5.5.2. Fork / Join 框架与传统线程池的区别6. Optional 类7. 接口中的默认方法与静态方法7.1. 接口中的默认方法8. 新时间日期 API8.1. 使用 LocalDate、LocalTime、LocalDateTime8.2. Instant 时间戳8.3. Duration 和 Period8.4. 日期的操纵8.5. 解析和格式化8.6. 时区的处理9. 其他新特性9.1. 重复注解和类型注解1. 新特性简介 速度更快 代码更少【增加了新的语法 Lambda 表达式】 强大的 Stream【API】 便于并行 最大化减少空指针异常 Optional 其中最核心的是 Lambda 表达式和 Stream 的 API。 2. Lambda 表达式 2.1. 为啥使用 Lambda 表达式？ 下面用一个具体的案例抛砖引玉，说明为什么要用 Lambda 表达式： whylambda Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码【将代码像数据一样进行传递】。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使 Java 的语言表达能力得到了提升。 从匿名内部类到 Lambda 表达式的转换： // 匿名内部类 Runnable r1 = new Runnable() { @Override public void run() { System.out.println(\"Hello World\"); } } // 转换成 Lambda 表达式 Runnable r1 = () -> System.out.println(\"Hello World\"); 使用匿名内部类做为参数传递到 Lambda 表达式的转换： // 原来使用匿名内部类作为参数传递 TreeSet ts = new TreeSet<>(new Comparator() { @Override public int compare(String o1，String o2) { return Integer.compare(o1.1ength(), o2.length()); } }); // 转换成 Lambda 表达式 TreeSet ts = new TreeSet<>( (o1, o2) -> Integer.compare(o1.length(), 02.lenth()) ); 2.2. Lambda 表达式语法 Lambda 表达式在 Java 语言中引入了一个新的语法元素和操作符。这个操作符为 ->，该操作符被称为 Lambda 操作符或剪头操作符。它将 Lambda 分为两个部分： 左侧：指定了 Lambda 表达式需要的所有参数 右侧：指定了 Lambda 体，即 Lambda 表达式要执行的功能 语法格式一：无参数，无返回值，Lambda 表达式只需要一条语句 Runnable r1 = () -> System.out.println(\"Hello lambda!\"); 语法格式二：Lambda 需要一个参数 Consumer fun = (args) -> System.out.println(args); 语法格式三：Lambda 只需要一个参数时，参数的小括号可以省略 Consumer fun = args -> System.out.println(args); 语法格式四：Lambda 需要两个参数，并且有返回值 BinaryOperator bo = (x, y) -> { System.out.println(\"实现函数接口方法\"); return x + y; }; 语法格式五：当 Lambda 体只有一条语句时，return 与大括号可以省略 BinaryOperator bo = (x, y) -> x + y; 语法格式六：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”，下面参数的 Long 可以省略 BinaryOperator bo = (Long x, Long y) -> { System.out.println(\"实现函数接口方法\"); return x + y; }; grammar 2.3. 类型推断 上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的，这就是所谓的“类型推断”。 2.4. 练习 trainning 3. 函数式接口 3.1. 什么是函数式接口？ 只包含一个抽象方法的接口，称为函数式接口。 你可以通过 Lambda 表达式来创建该接口的对象【若 Lambda 表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明】。 我们可以在任意函数式接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。 3.2. 自定义函数式接口 @FunctionalInterface public interface MyNumber { public double getValue(); } 函数式接口中使用泛型： @FunctionalInterface public interface MyFunc { public T getValue(T t); } 3.3. 作为参数传递 Lambda 表达式 public String toUpperString(MyFunc mf, String str) { return mf.getValue(str); } 作为参数传递 Lambda 表达式： String newStr = toUpperString((str) -> str.toUpperCase(), \"abcde\"); System.out.println(newStr); 作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收 Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。 3.4. Java 内置函数式接口 Java 内置四大核心函数式接口： 函数式接口 接口类型 参数类型 返回类型 用途 Consumer 消费型接口 T void 对类型为 T 的对象应用操作，包含方法 void accept(T t) Supplier 供给型接口 无 T 返回类型为 T 的对象，包含方法：T get() Function 函数型接口 T R 对类型为 T 的对象应用操作，并返回结果。结果为 R 类型的对象。包含方法：R apply(T t) Predicate 断定型接口 T boolean 确定类型为 T 的对象是否满足某约束，并返回 boolean 值。包含方法：boolean test(T t) LambdaTest.java 其他接口： 函数式接口 参数类型 返回类型 用途 BiFunction T，U R 对类型为 T，U 参数应用操作，返回 R 类型的结果，包含方法为 R apply(T t, U u) UnaryOperator【Function 子接口】 T T 对类型为 T 的对象进行一元运算，并返回 T 类型的结果，包含方法为 T apply(T t) BinaryOperator【BiFunction 子接口】 T T 对类型为 T 的对象进行二元运算，并返回 T 类型的结果，包含方法为 T apply(T t1, T t2) BiConsumer T，U void 对类型为 T，U 参数应用操作，包含方法为 void accept(T t, U u) ToIntFunction、ToLongFunction、ToDoubleFunction T int、long、double 分别计算 int，long，double 值的函数 IntFunction、LongFunction、DoubleFunction int、long、double R 参数分别为 int，long，double 类型的函数 4. 方法引用与构造器引用 4.1. 方法引用 当要传递给 Lambda 体的操作，已经有实现的方法了，可以使用方法引用【实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致】！ 方法引用：使用操作符 :: 将方法名和对象或类的名字分隔开来。如下三种主要使用情况： 对象::实例方法 类::静态方法 类::实例方法 例如： (x) -> System.out.println(x); // 等同于： System.out::println; 例如： BinaryOperator bo = (x, y) -> Math.pow(x, y); // 等同于 BinaryOperator bo = Math:pow 例如： compare((x, y) -> x.equals(y), \"abcdef\", \"abcdef\"); // 等同于 compare(String::equals, \"abcdef\", \"abcdef\"); 注意：当需要引用方法的第一个参数是调用对象，并且第二个参数是需要引用方法的第二个参数【或无参数】时：ClassName::methodName。 4.2. 构造器引用 格式：ClassName::new 与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，与构造器参数列表要与接口中抽象方法的参数列表一致！ 例如： Function fun = (n) -> new MyClass(n); // 等同于 Function fun = MyClass::new 4.3. 数组引用 格式：type[]::new 例如： Function fun = (n) -> new Integer[n]; // 等同于 Function fun = Integer[]::new method 5. Stream API 5.1. 了解 Stream Java 8 中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API【java.util.stream.*】。Stream 是 Java 8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。 5.2. 什么是 Stream 流【Stream】到底是什么呢？它本质上是数据渠道，用于操作数据源【集合、数组等】所生成的元素序列。 “集合讲的是数据，流讲的是计算！” 注意： Stream 自己不会存储元素。 Stream 不会改变源对象。相反，他们会返回一个持有结果的新 Stream。 Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。 5.3. Stream 的操作三个步骤 创建 Stream：一个数据源【如：集合、数组】，获取一个流 中间操作：一个中间操作链，对数据源的数据进行处理 终止操作【终端操作】：一个终止操作，执行中间操作链，并产生结果 Figure: Stream 的操作步骤 5.3.1. 创建 Stream 创建 Stream： Java 8 中的 Collection 接口被扩展，提供了两个获取流的方法： default Stream stream()：返回一个顺序流 default Stream parallelStream()：返回一个并行流 由数组创建流： Java 中的 Arrays 的静态方法 stream() 可以获取数组流： static Stream stream(T[] array)：返回一个流 重载形式，能够处理对应基本类型的数组： public static IntStream stream(int[] array) public static LongStream stream(long[] array) public static DoubleStream stream(double[] array) 由值创建流： 可以使用静态方法 Stream.of()，通过显示值创建一个流。它可以接收任意数量的参数： public static Stream of(T... values)：返回一个流 由函数创建流，创建无限流： 可以使用静态方法 Stream.iterate() 和 Stream.generate()，创建无限流： 迭代：public static Stream iterate(final T seed, final UnaryOperator f) 生成：public static Stream generate(Supplier s) StreamCreationTest.java 5.3.2. Stream 的中间操作 多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。 筛选与切片： filter(Predicate p)：接受 Lambda，从流中排除某些元素 distinct()：筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 limit(long maxSize)：截断流，使其元素不超过给定数量 skip(long n)：跳过元素，返回一个扔掉了前 n 个元素的流，若流中元素不足 n 个，则返回一个空流，与 limit(n) 互补 StreamFilterSliceTest.java 映射： map(Function f)：接收一个函数作为参数，该函数会被应用到每个函数上，并将其映射成一个新的元素 mapToDouble(ToDoubleFuntion f)：接收一个函数作为参数，该函数会被应用到每个函数上，产生一个新的 DoubleStream mapToInt(ToIntFunction f)：接收一个函数作为参数，该函数会被应用到每个函数上，产生一个新的IntStream mapToLong(ToLongFunction f)：接收一个函数作为参数，该函数会被应用到每个函数上，产生一个新的LongStream flatMap(Function f)：接收一个函数作为参数，将流中的每一个值都换成另外一个流，然后把所有的流连接成一个流 StreamMapTest.java 排序： sorted()：产生一个新流，其中按自然顺序排序 sorted(Comparator comp)：产生一个新流，其中按比较器顺序排序 StreamSortTest.java 5.3.3. Stream 的终止操作 终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void。 查找与匹配： allMath(Predicate p)：检查是否匹配所有元素 anyMatch(Predicate p)：检查是否匹配至少一个元素 noneMatch(Predicate p)：检查是否没有匹配所有元素 findFirst()：返回第一个元素 findAny()：返回当前流中的任意元素 count()：返回流中元素总数 max(Comparator c)：返回流中最大值 min(Comparator c)：返回流中最小值 foreach(Comparator c)：内部迭代【使用 Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代---它帮你把迭代做了】 StreamTerminateTest.java 规约： reduce(T iden, BinaryOperator b)：可以将流中元素反复结合起来，得到一个值。返回 T reduce(BinaryOperator b)：可以将流中元素反复结合起来，得到一个值。返回 Option 备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。 收集： collect(Collector c)：将流转换为其他形式。接收一个 Collector 接口的实现，用于给 Stream 中元素做汇总的方法。 Collector 接口中方法的实现决定了如何对流执行收集操作【如收集到 List、Set、Map】。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下： Collectors.toList()：返回 List 类型，用于把流中元素收集到 List Collectors.toSet()：返回 Set 类型，用于把流中元素收集到 Set Collectors.toCollection()：返回 Collection 类型，用于把流中元素收集到创建的集合 Collectors.counting()：返回 Long 类型，用于计算流中元素的个数 Collectors.summingInt()：返回 Integer 类型，用于对流中元素的整数属性求和 Collectors.averagingInt()：返回 Double 类型，计算流中元素 Integer 属性的平均值 Collectors.summarizingInt()：返回 IntSummaryStatistics 类型，用于收集流中 Integer 属性的统计值，如：平均值 Collectors.joining()：返回 String 类型，连接流中每个字符串 Collectors.maxBy()：返回 Optional 类型，根据比较器选择最大值 Collectors.minBy()：返回 Optional 类型，根据比较器选择最小值 Collectors.reducing()：返回规约产生的类型，从一个作为累加器的初始值开始，利用 BinaryOperator 与流中元素逐个结合，从而规约成单个值 Collectors.collectingAndThen()：返回转换函数返回的类型，包裹另一个收集器，对其结果转换函数 Collectors.groupingBy()：返回 Map> 类型，根据某属性值对流分组，属性为 K，结果为 V Collectors.partitioningBy()：返回 Map> 类型，根据 true 或 false 进行分区 StreamReduceTest.java 5.3.4. Stream练习 StreamTrainingTest.java 5.4. 并行流与串行流 并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。 Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。 5.5. 了解 Fork 和 Join 框架 5.5.1. Fork 和 Join 的简介 Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分【Fork】成若干个小任务【拆到不可再拆时】，再将一个个的小任务运算的结果进行 Join 汇总。 Figure: Fork 和 Join 框架 5.5.2. Fork / Join 框架与传统线程池的区别 采用“工作窃取”模式【Work-Stealing】： 当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。 相对于一般的线程池实现，Fork / Join 框架的优势体现在对其中包含的任务的处理方式上。在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行，那么该线程会处于等待状态。而在 Fork / Join 框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行。这种方式减少了线程的等待时间，提高了性能。 forkjoin 6. Optional 类 Optional 类【java.util.Optional】是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 常用的方法： Optional.of(T t)：创建一个 Optional 实例 Optional.empty()：创建一个空的 Optional 实例 Optional.ofNullable(T t)：若 t 不为 null，创建 Optional 实例，否则创建空实例 isPresent()：判断是否包含值 orElse(T t)：如果调用对象包含值，返回该值，否则返回 t orElseGet(Supplier s)：如果调用对象包含值，返回该值，否则返回 s 获取的值 map(Function f)：如果有值对其处理，并返回处理后的 Optional，否则返回 Optional.empty() flatMap(Function mapper)：与 map 类似，要求返回值必须是 Optional optional 7. 接口中的默认方法与静态方法 7.1. 接口中的默认方法 Java 8 中允许接口中包含具有具体实现的方法，该方法称为“默认方法”，默认方法使用 default 关键字修饰。 例如： MyFun.java 接口默认方法的“类优先”原则 若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时： 选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。 接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法【不管方法是否是默认方法】，那么必须覆盖该方法来解决冲突。 defaultmethod Figure: 接口默认方法 上图演示了接口冲突的情况。 8. 新时间日期 API 8.1. 使用 LocalDate、LocalTime、LocalDateTime LocalDate、LocalTime、LocalDateTime 类的实例是不可变的对象，分别表示使用 ISO-8601 日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。 ISO-8601 日历系统是国际标准化组织制定的现代公民的日期和时间的表示法。 对应的具体方法见：https://docs.oracle.com/javase/8/docs/api/ 8.2. Instant 时间戳 用于“时间戳”的运算。它是以 Unix 元年【传统的设定为 UTC 时区 1970 年 1 月 1 日午夜时分】开始所经历的描述进行运算。 8.3. Duration 和 Period Duration：用于计算两个“时间”间隔 Period：用于计算两个“日期”间隔 8.4. 日期的操纵 TemporalAdjuster：时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。 TemporalAdjusters：该类通过静态方法提供了大量的常用 TemporalAdjuster 的实现。 8.5. 解析和格式化 java.time.format.DateTimeFormatter 类，该类提供了三种格式化方法： 预定义的标准格式 语言环境相关的格式 自定义的格式 8.6. 时区的处理 Java 8 中加入了对时区的支持，带时区的时间为分别为：ZonedDate、ZonedTime、ZonedDateTime。 其中每个时区都对应着 ID，地区 ID 都为 “{区域}/{城市}”的格式，例如：Asia/Shanghai 等。 ZoneId 类中包含了所有的时区信息： getAvailableZoneIds()：可以获取所有时区时区信息 of(id)：用指定的时区信息获取 ZoneId 对象 newdatetimeapi 9. 其他新特性 9.1. 重复注解和类型注解 Java 8 对注解处理提供了两点改进：可重复的注解及可用于类型的注解。 annotation Copyright © hzhiping 2019 all right reserved，powered by Gitbook文章最后修订时间： 2025-04-05 18:37:04 "}}